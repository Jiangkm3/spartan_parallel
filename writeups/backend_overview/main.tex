\documentclass{article}
\usepackage[letterpaper, total={6in, 8in}]{geometry}
\usepackage{xcolor}
\usepackage{amsfonts}

\newcommand{\red}[1] {\color{red}#1\color{black}}
\newcommand{\code}{\texttt}
\newcommand{\Qbound}{Q_{\mathtt{bound}}}
\newcommand{\Qsum}{Q_{\mathtt{sum}}}
\newcommand{\Qmax}{Q_{\mathtt{max}}}
\newcommand{\qmax}{q_{\mathtt{max}}}
\newcommand{\qrev}{q_{\mathtt{rev}}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\RLC}{\mathtt{RLC}}
\newcommand{\Z}{\widetilde{Z}}
\newcommand{\ABC}{\widetilde{ABC}}
\newcommand{\eq}{\widetilde{\mbox{eq}}}
\newcommand{\valid}{\tilde{\mbox{valid}}}
\newcommand{\iob}{io_{\mathtt{BLOCK}}}
\newcommand{\ioe}{io_{\mathtt{EXEC}}}

\newcommand{\PERMB}{\mathtt{PERM_{BLOCK}}}
\newcommand{\PERME}{\mathtt{PERM_{EXEC}}}
\newcommand{\ROOTE}{\mathtt{ROOT_{EXEC}}}
\newcommand{\ROOTB}{\mathtt{ROOT_{BLOCK}}}
\newcommand{\psb}{\mathtt{ps_{block}}}
\newcommand{\pse}{\mathtt{ps_{exec}}}
\newcommand{\ps}{\mathtt{ps}}
\newcommand{\eqq}{\stackrel{?}{=}}

\title{Backend Overview}
\author{Kunming Jiang}
\date{Nov 9, 2023}

\begin{document}

\maketitle

\section{Introduction}\label{sec:intro}

In this document, we describe details of the backend of \code{circ\_blocks}. The backend protocol assumes that the program has been divided into basic blocks, with the instance, inputs, and witnesses of each basic block supplied by the frontend and the prover. The centerpiece of the backend is a proof system called \code{spartan\_parallel} and its derived version \code{spartan\_pseudo\_parallel}. We examine the backend through three scopes: the required inputs, the additional witnesses generated after the random challenges, and details of \code{spartan\_parallel}.

% --

\section{Background and Terminology}\label{sec:term}

A proof system involves two parties: a Prover $\P$ and a Verifier $\V$. Given a program $f$ and an input $x$, $\P$ wants to convince $\V$ that an assignment $y$ is the correct output, i.e. $y = f(x)$ is the result of a correct execution of $f$. $\P$ does so by engaging $\V$ in a proof system, which needs to satisfy three requirements:
\begin{enumerate}
    \item\label{req:complete} \emph{Completeness}: If $y$ is the correct output, then $\V$ should always accept the proof.
    \item\label{req:sound} \emph{Soundness}: If $y$ is not the correct output, then $\V$ should reject with \emph{overwhelming probability}.
    \item\label{req:succinct} \emph{Succinctness}: $\P$ should run in $O(r_f)$ time, while $\V$ shuold run in \emph{approximately} $O(\log r_f)$ time, where $r_f$ is the runtime of the program $f$.
\end{enumerate}

One strategy for such proof system is to convert the program into an \emph{R1CS circuit}. The idea is to translate the instructions line-by-line into degree-2 arithmetic constraints. In particular, each constraint can be expressed as $az_i\cdot bz_i - cz_{i+1} = 0$, where $z_i$ and $z_{i+1}$ are the program states before and after the instruction, and $a$, $b$, and $c$ are vectors that can perform any arbitrary linear combination on the program states.

Now, assume that $f$ can be expressed using $M$ degree-2 constraints, and the collection of all program states that will be used in the proof can be described using $N$ variables. We can then describe the circuit using an R1CS \emph{Instance}, which is consisted of three $M\times N$ matrices $A$, $B$, $C$ to express the constraints, and a length-$N$ vector $z$ to express the program states. The circuit satisfiability problem is then equivalent to checking the correctness of:
$$Az \cdot Bz - Cz = 0$$

One such proof system to efficiently verify the correctness of the equation is called \code{spartan}. Specifically, let $m = \log M$, $n = \log N$, \code{spartan} allows $\P$ to reduce the correctness of the equation down to a single claim
$$z(r_y) \eqq e$$
in $O(M\cdot N)$ time, and $\V$ to verify the reduction in $O(m + n)$ time. To verify the claim $z(r_y) \eqq e$. $\P$ commits to the program states $z$ at the very beginning, and reveals $z(r_y)$ to $\V$ at the end of the proof. These two steps take $O(M\cdot N)$ for $\P$ and $O(\sqrt{M\cdot N})$ for $\V$, making the total $V$ runtime $O(m + n + \sqrt{M\cdot N})$. 

In this work, we expand on \code{spartan} to tackle a data-paralleled version of the R1CS problem. Assume that we now have $P$ instances $I_0\dots I_{P-1}$. For each instance $I_i = (A_i, B_i, C_i)$, $\P$ wants to convince $\V$ that there exists $Q_i$ vectors $z_{i, 0}\dots z_{i, Q_i-1}$ such that
$$\forall_{i\in [0, P), j \in [0, Q_i)}, A_iz_{i, j} \cdot B_iz_{i, j} - C_iz_{i, j} = 0$$

Let $p = \log P$, $q_i = \log Q_i$, $\Qmax = \max_i Q_i$, $\qmax = \log \Qmax$, and $\Qsum = \sum_i Q_i$, we developed a new proof system called \code{spartan\_parallel} to verify the correctness of the above equation in $O(\Qsum \cdot M \cdot N)$ for $\P$ and $O(p + \qmax + m + n + \sum_i \sqrt{Q_i\cdot M\cdot N})$ for $\V$. We describe details of \code{spartan\_parallel} in section \ref{sec:block_correctness}.

% --

\section{Input Format}\label{sec:input}

To understand how \code{spartan\_parallel} fits into the overall backend protocol of \code{circ\_blocks}, we need to start by examining the output of the frontend, which is also the input of the backend. The frontend \code{circ\_blocks} divides a program into $P$ basic blocks of similar sizes. During each execution, depending on the input, each basic block can be executed different number of times. Assume that for one particular execution, each block $B_i$ is executed $Q_i$ times. This leads to the following strategy to verify the correctness of the execution:
\begin{enumerate}
    \item \emph{Verifying the correctness of every block execution}. We concatenate the program states before and after each execution of each block, together with any intermediate values computed within each block, into a $z$ vector. There are $\sum_{i\in [0, P)} Q_i$ such $z$ vectors. Let the frontend provide the instance $I_i$ of each block $B_i$, we can use \code{spartan\_parallel} to prove that every block has been executed correctly.
    \item \emph{Verifying the correctness of block transition}. The next step is to verify that inputs and outputs across the instances are consistent. This can be verified by listing the $z$'s in execution order, and check that the output state of the previous block is the input state of the next block. We also need to check that the prover is executing the right block. The simplest way is to include the block label as part of program state and check it inside each block.
    \item \emph{Verifying the correctness of program state permutation}. We note that the previous two steps require $z$'s to be provided in two different orders (by block and by execution order). The final step is to verify that these two orderings of $z$'s are indeed permutations of each other. We do so by constructing two polynomials, each with their roots set to the entries of one of the two $z$ orderings. $\V$ then samples a random point and checks whether the two polynomials agree on that random point.
\end{enumerate}

\noindent These three steps lay out all required inputs for the backend:
\begin{itemize}
    \item Instances:
    \begin{itemize}
        \item \code{BLOCK}: $P$ instances to describe all blocks
        \item \code{CONSIS}: one instance to prove consistency in block transition
        \item $\PERMB$ and $\PERME$: two instances that constructs polynomials to verify permutation
    \end{itemize}
    \item Program States: $\sum_i Q_i$ for each execution of each block, grouped in two orderings.
    \begin{itemize}
        \item $\psb$: A $P\times \Qmax$ matrix of $z$'s. Each row $i$ corresponds to all $Q_i$ executions of block $i$. If there aren't $\Qmax$ executions, the remaining entries are either filled with 0 or skipped (see section \ref{sec:block_correctness})
        \item $\pse$: A length-$\sum_i Q_i$ vector of $z$'s sorted in execution order.
    \end{itemize}
\end{itemize}

We note that the backend is consisted of four independent proofs, each corresponding to \code{BLOCK}, \code{CONSIS}, $\PERMB$, and $\PERME$. However, some of these proofs use the same $z$. For example, $\psb$ is used in both \code{BLOCK} and $\PERMB$. How can $\P$ convince $\V$ that the same $\psb$ is supplied to both proofs? The solution is to force $\P$ to generate one commitment of $\psb$ for both proofs. Through \code{spartan\_parallel}, $\P$ reduces \code{BLOCK} and $\PERMB$ to two claims: $\psb(r_1) \eqq e_1$ and $\psb(r_2) \eqq e_2$. $\P$ then opens the commitment on both $r_1$ and $r_2$ to complete the proof. This \emph{shared commitment} property turns out to be a major obstacle for circuit design, which will show up in section \ref{sec:consistency} and \red{???}.

Finally, in the next sections, we will reveal that instants and program states need to be further divided for technical reasons. For this reason, we will deliberately avoid using the terms $\psb$ and $\pse$. We will revisit the detailed input format and instances in section \red{???}, and better define the composition of $\psb$ and $\pse$.

% --

\section{Proof of Block Correctness and \code{spartan\_parallel}}\label{sec:block_correctness}

Given the instances $I_i = (A_i, B_i, C_i)$ of all $P$ blocks and vectors $z_{i, j}$ to describe the program states before, after, and during each of the $Q_i$ executions of each block $i$. The goal of this proof is to verify that all $\Qsum = \sum_i Q_i$ block executions are correct.

To simplify the proof, we assume that $P$, $Q_i$, as well as the size of each instances $X_i$ and $Y_i$ are all powers of two. We can do so by \emph{padding} the instance list and program state vectors with dummy entries. Dummy instances can be viewed as unreachable dead codes in the program, so they don't require extra reasoning. Dummy program states can be expressed by including a \emph{valid variable} in the program state. Valid variable is set to 0 if the state is a dummy, 1 otherwise. Finally, for \code{spartan\_parallel} to be most efficient, we want the number of constraints of all block instances to be similar. This can be achieved using various tricks, like splitting basic blocks and merging control flows.

\subsection{Composition of $z_{i, j}$}\label{io_composition}
While from the perspective of the proof system, $z_{i, j}$ (referred to as $z$ for the rest of the subsection) can be viewed as a single vector, from the perspective of \code{circ\_blocks} as a whole, $z$ is divided as the following:
$$z = ((v, i, 0, o), w)$$
where, let $\ell_z$ be the length (number of entries) of $z$, assume $\ell_z$ is a power of 2 and $\ell_z \geq 8$,
\begin{itemize}
    \item $v$ is a length-1 valid bit which is set to 0 if $z$ is a dummy entry, 1 otherwise. The valid bit is enforced by the block instances to be either 0 or 1. \emph{$v$ also serves as the constant value $1$ used by the instance.}
    \item If $v$ is 0, completeness only holds if all entries of $z$ are set to 0. If $v$ is 1, the rest of $z$ are defined below:
    \item $i$ has length $(\ell_z / 4 - 1)$ and records the input state of the block. We can always pad $i$ with 0 if it is not long enough, same with $o$ and $w$.
    \item $0$ is a dummy variable.
    \item $o$ has length $(\ell_z / 4 - 1)$ and records the output state of the block.
    \item $w$ has length $(\ell_z / 2)$ and records all intermediate values that will be computed within the block.
\end{itemize}

We note that the first half, $z[0] = (v, i, 0, o)$, will later be used by permutation and consistency check, while the second half, $z[1] = w$, is only relevant to the block correctness proof. We define $io = (v, i, 0, o)$, and as a result, $z = (io, w)$.

Finally, to standardize the size of program state across all proofs, \emph{let $Y$ be the length of $io$ (and $w$)}. Thus, each $z$ can be viewed as a length-$2Y$ vector. We also assume $X = O(Y)$, where $X$ is the number of constraints. In the remainder of the section, we treat $O(X)$, $O(Y)$, and $O(\ell_f)$ as the same value.

\subsection{Overview of \code{spartan\_parallel}}
With the format $z = (io, w)$ out of the way, the next step is to provide an overview of the mechanisms behind \code{spartan\_parallel}.

As mentioned earlier, there are $P$ block instances, each block $i$ corresponding to $Q_i$ executions and in turn, $Q_i$ $(io, w)$ vectors. Let $\Qmax = \max_i Q_i$ and $\Qsum = \sum_i Q_i$, a naive data-parallel implementation of \code{spartan} represents and commits all $z$ vectors into a $P\times \Qmax\times 2Y$ hypermatrix. This construction allows $\V$ to verify the reduction in $O(\log (P\cdot \Qmax\cdot 2Y))$ and the commitment opening in $O(\sqrt{P\cdot \Qmax\cdot Y})$ time, at the cost of $\P$ taking $O(P\cdot \Qmax\cdot Y)$ time, which exceeds the program runtime of $O(\Qsum\cdot Y)$. Furthermore, the time for $\V$ to open the commitment is also not ideal compare to the quantity of $z$ vectors that are actually valid.

To solve these problems, \code{spartan\_parallel} improves on the naive version in two main ways:
\begin{enumerate}
    \item \code{spartan\_parallel} exploits the fact that all invalid $z$ vectors are 0-vectors. As a result, once it learns values of $Q_i$, it can skip all multiplications and additions for the invalid vectors, reducing $\P$'s time and space complexity to $O(\Qsum\cdot Y)$.
    \item Instead of committing the entire hypermatrix of $z$, \code{spartan\_parallel} commits the $z$ vectors instance by instance. This means $\V$ needs to open $P$ commitments of $Q_i\times 2Y$ $z$-matrices and manually combine them together. However, each opening now takes $O(\sqrt{Q_i\cdot Y})$ time, decreasing the overall commitment opening time.
\end{enumerate}

\subsection{The \code{spartan\_parallel} Proof System}
We now succinctly describe the \code{spartan\_parallel} proof system:
\begin{enumerate}
    \item The value $P$ and the instances for all $P$ blocks are provided by the frontend.
    \item All $Q_i$ and the program states $(io, w)$ of all $\Qsum$ executions are provided by $\P$ and committed into $P$ commitments, one for each block.
    \item $\P$ concatenates each $(io_{i, j}, w_{i, j})$ pair into a single vector $z_{i, j}$.
    \item $\P$ computes three polynomials, each extending all $\Qsum$ length-$X$ vectors $Az$, $Bz$, or $Cz$. This step takes $O(\Qsum\cdot Y)$ time since $\P$ can skip all the zeros.
    \item $\P$ engages $\V$ in the first sumcheck protocol to prove $\sum_{p, q, x} \eq\cdot (Az \cdot Bz - Cz) = 0$. The sumcheck lasts $p + \qmax + x$ rounds but $\P$ only needs to perform $O(\Qsum\cdot Y)$ evaluations and bindings. At the end of the sumcheck, $\V$ samples vectors $r_p, r_q, r_x$ of length $p, \qmax, x$.
    \item $\V$ samples three random values $r_A$, $r_B$, and $r_C$. $\P$ computes a polynomial $\Z_{r_q}$ that extends all $z_{i, j}$ and binds to $r_q$, as well as a polynomial $\ABC = r_A\cdot A + r_B\cdot B + r_C\cdot C$.
    \item $\P$ engages $\V$ in the second sumcheck protocol to prove $\sum_{p, y} \eq\cdot \ABC \cdot \Z_{r_q} = e$, where $e$ is the claim from the first sumcheck. Note that we cannot skip the $p$ rounds because $p$ is a parameter for both $\ABC$ and $Z$ and thus is not degree-1. At the end of the sumcheck, $\V$ samples vectors $r_p', r_y$ of length $p, y$.
    \item $\P$ opens all $P$ commitments of $io$ and $w$ on $r_q, r_y$ and proves that their linear combination using $r_p'$ is $\Z_{r_q}(r_p', r_y)$. This takes $O(\Qsum\cdot Y)$ time for $\P$ and $O(\sqrt{P\cdot \Qmax\cdot Y})$ time for $\V$.
    \item Finally, $\P$ opens one commitment on all instances to reveal the evaluation on $r_p', r_x, r_y$.
\end{enumerate}

\subsection{Commitments and Shared Commitments}

The program states of the block correctness proof is represented as $z = (io, w)$. As explained earlier, $io$ is the input and output state of each block execution, sorted in block order. These values will also be used by $\PERMB$. As a result, the commitment of $io$, which is actually $P$ commitments each describing $Q_i \times Y$ entries, is a shared commitment. On the other hand, commitment for $w$ is used exclusively by the block correctness proof.

As a result, we define the shared commitment of $\psb$ to be the commitment of $io$. Runtime and memory constraint in the block correctness proof dictates that $\psb$ will be committed as $P$ commitments, which later also dictates the strategy used by the proof $\PERMB$.

% --

\section{Proof of Consistency and \code{spartan\_pseudo\_parallel}}\label{sec:consistency}

The next proof is to verify that, when ordering the program states in execution order, the output state of the previous block execution matches the input state of the next block execution. As explained previously, checks on whether the correct block is being executed can be done within each block as long as the block label is included in the input and output states.

\subsection{Constraint Composition}\label{consis_composition}

We start by examining what needs to be done to check consistency. Let $\Qsum$ be the total number of block executions and let the execution-ordered programs states be $io_0 \dots io_{\Qsum - 1}$ (which should be a permutation of the $io$'s in the block correctness proof). As described in section \ref{io_composition}, each $io_i$ is consisted of $(v_i, i_i, 0, o_i)$. For each consecutive $io_i$, $io_{i+1}$ pair, consistency proof needs to check that:
\begin{enumerate}
    \item $v_{i + 1} = 1 \Rightarrow v_i = 1$ and $v_i = 0 \Rightarrow v_{i + 1} = 0$.
    \item $v_{i + 1}\cdot o_i = i_{i + 1}$. All $Y / 2 - 1$ entries in $o_i$ should match their counterpart in $i_{i + 1}$ unless program state $i + 1$ is invalid.
\end{enumerate}

\subsection{Naive Approaches to Check Consistency}

Naively, the consistency proof seems easily parallelizable: each constraint of the consistency proof only uses variables from two consecutive states: $io_i$ and $io_{i + 1}$. As a result, the frontend can generate one R1CS instance that checks consistency of $io_i$ and $io_{i + 1}$, and the backend can run \code{spartan\_parallel} with $P = 1$ and $Q_0 = \Qsum$, and let $z_{0, i} = (io_i, io_{i + 1})$. Since there is only one instance, to simplify notation, we define $Q = Q_0$ and $z_i = z_{0, i}$.

However, this approach turns out to be infeasible. This is because the proof is eventually reduced to the claim $z(r_q, r_y) \eqq e$. What commitment should be used to verify this claim? $\P$ cannot use a single commitment on $z$, because $z_{i} = (io_i, io_{i + 1})$, which means that $z_i$ and $z_{i+1}$ share $io_{i + 1}$. It would be extremely difficult to capture this relationship using one single commitment on the entire $z$. It is equally infeasible to commit the two halves of $z$ separately. This is because when joining all $\Qsum$ $(io_i, io_{i + 1})$'s together, the $io_i$'s form a $(\Qsum - 1)\times Y$ matrix consisted of $io_0, \dots, io_{\Qsum - 2}$, while $io_{i + 1}$'s form a $(\Qsum - 1)\times Y$ matrix consisted of $io_1, \dots, io_{\Qsum - 1}$. Despite how similar the two matrices look, their interpolated polynomials are completely different. As a result, it is still unclear how $\P$ can efficiently convince $\V$ that the two commitments are related.
 
The alternative approach is to express the entire consistency check as one large instance. In this model, the frontend first provides a bound $\Qbound = \max(\Qsum)$ and generates constraints that check the consistency for all $\Qbound - 1$ consecutive $(io_i, io_{i + 1})$ pairs. If the actual execution does not produce $\Qbound$ valid program states, the constraints listed in section \ref{consis_composition} forces $\P$ to append invalid $io$'s to the back of the list.

\subsection{Leverage Parallel Properties}

This alternative encoding allows $\P$ to run in $O(\Qbound)$ time and $\V$ in $O(\log \Qbound + \sqrt{\Qbound})$ time. Can we improve the runtime further? In particular, we want:
\begin{enumerate}
    \item \label{impr:min_cons} Minimize the number of constraints, utilize the data-parallel feature of \code{spartan\_parallel} as much as we can.
    \item \label{impr:min_comp} Avoid computations on invalid program stats. If we can skip all computations on invalid $io$'s, then $\P$ can achieve $O(\Qsum)$ time and $V$ can achieve $O(\log\Qsum + \sqrt{\Qsum})$ time.
\end{enumerate}

\subsubsection{Achieve Maximum Parallelism}

To achieve improvement \ref{impr:min_cons}, we want to parallelize as much work as possible. Our first observation is that instead of checking every entry in $o_i$ matches their counterpart in $i_{i + 1}$, $\P$ can perform the same random linear combination (RLC) on $o_i$ and $i_{i + 1}$, and convince $\V$ that the results of the two RLCs are the same. Since random linear combinations are performed within each $io$, the frontend can produce one instance that performs RLC on one $io$, and $\P$ and $\V$ can parallelize the verification $\Qsum$ times. This process is described below:
\begin{enumerate}
    \item After $\P$ commits to all $io$'s, $\V$ samples a random challenge $r$.
    \item For each $io = (v, i_1, \dots i_{Y/2 - 1}, 0, o_1, \dots o_{Y/2 - 1})$, $\P$ computes
    $$\displaystyle\RLC(i) = v + \sum_{i = 1}^{Y/2 - 1} i_i\cdot r^i \mbox{ and } \RLC(o) = v + \sum_{i = 1}^{Y/2 - 1} o_i\cdot r^i$$
    \item For each $io_i$, $\P$ computes $\RLC(io_i) = (v_i, v_i\RLC(i_i), v_i\RLC(o_i))$ and uses \code{spartan\_parallel} with $P = 1$ and $Q = \Qsum$ to convince $\V$ that all $\RLC(io_i)$ are computed correctly.
    \item Finally, $\P$ concats all $\RLC(io_i)$ into a length-$\Qbound$ list. The frontend generates an instance that verifies $v_{i+1}\cdot v_i\RLC(o_i) = v_{i+1}\RLC(i_{i+1})$ for all $i\in [0, \Qbound - 1)$. $\P$ and $Q$ engage in an $O(\Qbound)$ verification process.
\end{enumerate}

We conclude this procedure with some addtional remarks:
\begin{enumerate}
    \item If $io_i$ is invalid, then $\RLC(io_i)$ would be a zero vector. This is crucial later to achieve improvement \ref{impr:min_comp}.
    \item If $io_i$ is valid, then $\RLC(i) = 1 + \sum i_i\cdot r^i$ and $\RLC(o) = 1 + \sum o_i\cdot r^i$ are almost never 0. This implicitly suggests that the consistency check will almost always fail if $\P$ orders a valid $io$ behind an invalid one. Thus, \emph{we don't need to explicitly check that all valid $io$'s are listed before the invalid ones}.
\end{enumerate}

\subsubsection{Pseudo-Parallelism and \code{spartan\_pseudo\_parallel}}

At the end of RLC, $\P$ convinces $\V$ that a list of $\RLC(io_i) = (v_i, v_i\RLC(i_i), v_i\RLC(o_i))$ is computed correctly. To finalize the consistency check of $\RLC(io_i)$, $\P$ engages $\V$ in another proof system using an instance $I$, this time with $\Qbound$ constraints of $v_{i+1}\cdot v_i\RLC(o_i) = v_{i+1}\RLC(i_{i+1})$. We have previously noted that $\RLC(io_i)$ is a zero-vector if $io_i$ is invalid. However, this observation can be further expanded:
\begin{itemize}
    \item If $io_i$ is invalid, then $io_{i+1}$ is also invalid, so both $\RLC(io_i)$ and $\RLC(io_{i+1})$ are a zero-vectors.
    \item Consistency between each pair of $\RLC(io_i)$ and $\RLC(io_{i+1})$ is checked using only one constraint. We let the $i$th constraint in $I$ checks the consistency between $\RLC(io_i)$ and $\RLC(io_{i+1})$. This means that if $io_i$ is invalid, all variables used by the $i$th constraint will be 0, and the constraint will be satisfied with both sides being 0.
    \item \red{There is a hidden third condition, which is that each row in $A$ has the same amount of non-zero entry, same with $B$ and $C$. This way, not only do we know which constraints are multiplied to 0, we also know which non-zero entries in $A$, $B$, and $C$ are multiplied to 0.}
\end{itemize}
It turns out that these two properties are enough to apply the basic idea behind \code{spartan\_parallel}. Instead of $Q$ proofs, each with $X$ constraints and $Y$ variables, we now have 1 proof with $Q\cdot Y$ non-zero variables and $Q\cdot X$ constraints that are \emph{multiplied to non-zero variables}. We call this construction a \emph{pseudo-parallel proof system} with
\begin{itemize}
    \item Number of proofs: $P = 1$
    \item Number of parallel constraints and inputs per proof: $Q_0 = Q = \Qsum$
    \item Base constraint size: $X = 1$
    \item Base input size: $Y = 3$ (then round to the next power of 2)
\end{itemize}
This construction allows the system to also support multiple proofs, each with different numbers of parallel inputs (and constraints), just like $P$ and $Q_i$ in \code{spartan\_parallel}. We will exploit this property later when discussing permutation.

Finally, during the RLC verification, $\P$ invokes \code{spartan\_parallel} with one instance. This means $\P$ has committed all $\Qsum$ copies of $\RLC(io_i)$ in a single commitment. This will also be what the pseudo-parallel proof system needs to support: one commitment per proof.

\subsection{The \code{spartan\_pseudo\_parallel} Proof System}

In the previous subsection, we introduced a pseudo-parallelism and properties that relate it to full data-parallelism. The next step is to modify \code{spartan\_parallel} to support pseudo-parallelism. We call this new proof system \code{spartan\_pseudo\_parallel}, described below:
\begin{enumerate}
    \item The one and only instance is provided by the frontend. $A$, $B$, and $C$ are of size $\Qbound X\times \Qbound Y$. $\P$ and $\V$ doesn't need to know $\Qbound$ as long as all $Q_i \leq \Qbound$.
    \item $P$, $Q_i$'s, and program states $\RLC(io_{i, j})$ of all $\Qsum$ executions are provided by $\P$ and committed into $P$ commitments, one for each proof. Each commitment $c_i$ represents a matrix of size $Q_i \times Y$.
    \item $\P$ sets $z_{i, j} = \RLC(io_{i, j})$. The entire $z$ is of size $P\times Q_i\times Y$.
    \item $\P$ computes $Az$, $Bz$, and $Cz$ and extends them to three polynomials. Each $Az$, $Bz$, and $Cz$ is of size $P\times Q_i \times X$. Note that the correct output of the matrix multiplication should be of size $P\times \Qbound \times X$, but $\P$ can skip the $Q_i \dots \Qbound$ part because they are all 0's. This step takes $O(\Qsum\cdot Y)$ time. \red{This step is possible because we only needs to read the first $O(Q_i)$ non-zero entries of the instances. If the constraints do not look exactly like each other, we cannot do this!}
    \item $Az$, $Bz$, $Cz$ are in the exact same format as in \code{spartan\_parallel}, so sumcheck 1 also stays the same. $\P$ engages $\V$ to prove $\sum_{p, q, x} \eq\cdot (Az \cdot Bz - Cz) = 0$ in $p + \qmax + x$ rounds, performing $O(\Qsum\cdot Y)$ evaluations and bindings. At the end of the sumcheck, $\V$ samples vectors $r_p, r_{qx}, r_x$ of length $p, \qmax, x$. Note that $\Qmax = \max_i(Q_i)\leq\Qbound$.
    \item $\V$ samples three random values $r_A$, $r_B$, and $r_C$. $\P$ computes a polynomial $\Z_{r_p}$ that extends all $z_{i, j}$ and binds to $r_p$ (instead of $r_q$! In \code{spartan\_pseudo\_parallel}, $P$ is the dimension only existed in $z$). $\P$ also computes polynomial $\ABC = r_A\cdot A + r_B\cdot B + r_C\cdot C$.
    \item $\P$ engages $\V$ in the second sumcheck protocol to prove $\sum_{q, y} \ABC \cdot \Z_{r_p} = e$, where $e$ is the claim from the first sumcheck. At the end of the sumcheck, $\V$ samples vectors $r_{qy}, r_y$ of length $\qmax, y$. Note that $r_{qx}$ and $r_{qy}$ are not related. $\V$ uses $(r_{qx}, r_x)$ to perform RLC on the constraints and $(r_{qy}, r_y)$ for RLC on $z$. \red{In \code{spartan\_parallel}, the sumcheck one output $r_p$ is applied to both the instance and $z$, which is why, in sumcheck 2, we need to introduce an additional polynomial $\eq_p$ to make it degree-1. In \code{spartan\_pseudo\_parallel}, sumcheck 1 produces $r_p$, which is only used by $z$, and $r_{qx}$, which is only used by the instance, so no degree-2 bindings, no $\eq$.}
    \item $\P$ opens all $P$ commitments of $io$ and $w$ on $r_{qy}, r_y$ and proves that their linear combination using $r_p$ is $\Z_{r_p}(r_{qy}, r_y)$. This takes $O(\Qsum\cdot Y)$ time for $\P$ and $O(\sqrt{P\cdot \Qmax\cdot Y})$ time for $\V$.
    \item Finally, $\P$ opens one commitment on all instances to reveal the evaluation on $r_{qx}, r_x, r_{qy}, r_y$.
\end{enumerate}
From $\V$'s perspective, \code{spartan\_pseudo\_parallel} is almost exactly like \code{spartan\_parallel}, except the challenge vectors are now ($r_p, r_{qx}, r_x, r_{qy}, r_y$) instead of ($r_p, r_p', r_q, r_x, r_y)$. $\P$ needs to pre-process the instances and inputs to make them fit \code{spartan\_parallel}, but none of the changes ultimately affect its runtime.

\subsection{Commitments and Shared Commitments}

Finally, we state the shared commitments introduced by the consistency proof. The $io$'s in execution order will be used by $\PERME$. Thus, the commitment of $io$ describing $\Qsum \times Y$ entries is a shared commitment, and we define it to be $\pse$.

% --

\section{Proofs of Permutation}\label{sec:permutation}

In this section, we use \code{spartan\_parallel} and \code{spartan\_pseudo\_parallel} to verify that values commited by $\psb$ and $\pse$ are indeed permutations of each other. 

\subsection{Permutation Basics}

Given two lists $a = (a_0, a_1, ..., a_{n-1})$, $b = (b_0, b_1, ..., b_{n-1})$, the goal is to prove that $b$ is a permutation of $a$. We can employ a simple idea from \red{XXX}: let $p_a$ be a degree-$n$ polynomial with roots $a_0, ..., a_{n-1}$ and $p_b$ be a degree-$n$ polynomial with roots $b_0, ..., b_{n-1}$. If $b$ is a permutation of $a$, then $p_a$ and $p_b$ are the same polynomial. This leads to the following proof:
\begin{enumerate}
    \item $\P$ commits to $a$ and $b$.
    \item $\V$ samples a random challenge $\tau$.
    \item $\P$ computes $p_a(\tau) = \prod_i (\tau - a_i)$ and $p_b(\tau) = \prod_i (\tau - b_i)$. It uses a proof system to convince $\V$ that $p_a(\tau)$ and $p_b(\tau)$ are computed correctly.
    \item Finally, $\V$ checks that $p_a(\tau) = p_b(\tau)$.
\end{enumerate} 

If $p_a$ and $p_b$ are not the same polynomial, it is extremely unlikely that they match on a random value $\tau$. Thus, $\V$ is convinced $a$ and $b$ are permutations of each other if $p_a(\tau) = p_b(\tau)$.

\subsection{Permutation of Sequences}

Now, instead of $a$ and $b$ being lists of values, we let them be lists of sequences. Let each $a_i = (a_{i, 0}, \dots a_{i, m-1})$ and ach $b_i = (b_{i, 0}, \dots b_{i, m-1})$. The goal is to check that $b = (b_0\dots b_{n-1})$ is a permutation of $a = (a_0\dots a_{n-1})$, i.e.:
$$\forall_i, \exists_j \mbox{ such that } \forall_k, a_{i, k} = b_{j, k} \ \mbox{ and }\ \forall_{i'}, \exists_{j'} \mbox{ such that } \forall_k, b_{i', k} = a_{j', k}$$

To verify the permutation, $\P$ computes an RLC on $a_i$ and $b_i$. Then, $\P$ can again construct two polynomials with roots being the values of $\RLC(a_i)$ and $\RLC(b_i)$. Details of the protocol is below:
\begin{enumerate}
    \item $\P$ commits to $a$ and $b$.
    \item $\V$ samples random challenge $\tau$ and $r$.
    \item For $i\in [0, n)$, $\P$ computes $\RLC(a_i) = \sum_k r^k \cdot a_{i, k}$ and $\RLC(b_i) = \sum_k r^k \cdot b_{i, k}$. It uses a proof system to convince $\V$ that all $\RLC(a_i)$ and $\RLC(b_i)$ are computed correctly.
    \item $\P$ then computes $p_a(\tau) = \prod_i (\tau - \RLC(a_i))$ and $p_b(\tau) = \prod_i (\tau - \RLC(b_i))$. It convinces $\V$ that they are correct using another proof.
    \item Finally, $\V$ checks that $p_a(\tau) = p_b(\tau)$.
\end{enumerate} 

\subsection{Permutation Check for $\pse$}

Applying the idea behind the permutation check to the backend, $\V$ wants to verify that the list of $io$ in block order (referred to as $\iob$) and the list of $io$ in execution order ($\ioe$) are permutations of each other. So $\P$ treats each $\iob$ as $a_i$ and each $\ioe$ as $b_i$, and constructs polynomials on them. To align with the block correctness and consistency check, $\P$ also needs to commit $\iob$ and $\ioe$ using $\psb$ and $\pse$ respectively.

We start by reasoning about the easier case. The commitment $\pse$ requires $\ioe$ to be expressed as a $\Qsum\times Y$ matrix, where each row corresponds to one $\ioe$ entry. This presents a natural way to compute the polynomial evaluation $p_\mathtt{EXEC}(\tau)$:
\begin{enumerate}
    \item $\P$ commits $\pse$.
    \item $\V$ randomly samples $\tau$ and $r$.
    \item \label{step:permE_root} For each ${\ioe}_i$, $\P$ computes $\tau - \RLC({\ioe}_i)$, where $\RLC({\ioe}_i) = \sum_{k = 0}^{Y-1} r^k \cdot {\ioe}_{i, k}$. $\P$ proves the correctness of all $\tau - \RLC({\ioe}_i)$ to $\V$.
    \item \label{step:permE_poly} Finally, $\P$ computes $p_\mathtt{EXEC}(\tau) = \prod_{i = 0}^{\Qsum - 1}(\tau - \RLC({\ioe}_i))$
\end{enumerate}

The above protocol closely resembles the consistency check: step \ref{step:permE_root} contains the majority of the constraints, and can be applied to each $io$ separately and verified in parallel, while step \ref{step:permE_poly} contains a small set of constraints that multiply derived values from multiple $\ioe$'s, and thus not so easily paralllelizable. Can we construct the instance in step \ref{step:permE_poly} in a way that $\P$ and $\V$ can apply \code{spartan\_pseudo\_parallel}?

The answer is yes. We can apply \code{spartan\_pseudo\_parallel} if the instance contains constraints that are: 1. structurally identical, 2. only involves inputs derived from two consecutive $io$'s, and 3. the inputs should all be 0 if the first $io$ is invalid. These requirements can be satisfied by computing the product recursively. For each $io_i$, let $\P$ supply two values $(x_i, \pi_i)$, where $x_i = \tau - \RLC({\ioe}_i)$ and $\pi_i = \prod_{j = i}^{\Qsum - 1} x_j$. This way, the constraints in step \ref{step:permE_poly} can be expressed as $\forall_i, \pi_i = x_i \cdot \pi_{i+1}$. However, this construct fails to address the issue of invalid $io$'s: when an $io$ is invalid, $\tau - \RLC({\ioe}_i) = \tau\neq 0$, so pseudo-parallelism does not hold.

To deal with this problem, $x$ needs to be expressed as $v_i \cdot (\tau - \RLC({\ioe}_i))$, but now the formular for $pi$ needs to change as well: if $io_{i + 1}$ is invalid, $pi_{i + 1}$ should be 0, but $pi_i$ should treat $pi_{i + 1}$ as if it is a 1 (otherwise multiplication would not work). We propose the following way to compute $pi_i$:
$$pi_i = v_i * x_i * (\pi_{i+1} + (1 - v_{i+1}))$$

With these in mind, we redesign the protocol:
\begin{enumerate}
    \item At the end of step \ref{step:permE_root}, $\P$ computes a list of $\ROOTE_i = (v, x, \pi, D_1, D_2)$
\end{enumerate}

% --

\section{Verifying the Final Output}\label{sec:final_output}

\end{document}